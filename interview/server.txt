服务器网络底层：
ET（边缘触发）/LT（水平触发）
ET模式下。epoll_wait调用后，底层通知下层有数据到来。应用层应该立即读完所有数据，直到反悔EA_AGAIN,否则底层不会再次通知。
LT模式下。如果应用层不一次读完。底层会反复通知应用层来读取。

epoll底层结构：
epoll开辟出epoll自己的内核高速cache区
1.红黑2叉树存储所有的文件描述符,当有新的socket到来时就插入
2.维持一个就绪链表，把有时间通知的文件加入链表里
3,用户应用程序只要发现链表不为空就是有就绪的socket到来,如果是ET模式，没有处理完的socket不会再放回链表里,LT模式没有处理完的socket还会放回链表

1.select和poll的缺点：
select 和 poll都是水平触发，也就是不读完会反复通知。
select返回所有的文件描述符，需要应用层循环去判断
select依赖文件描述符fd,fd默认是1024个。
select和poll有新的socket新增的时候会把整个fd_set从用户拷到内核,epoll只需要把新的socket加到红黑树

epoll和IOCP的区别
epoll只负责通知用户数据来了。需要用户直接去读取。这时会产生copy
IOCP内核中返回了数据缓冲，可以直接使用


服务器架构:
一致性hash问题：

传统hash取模的方式是对服务器数量取模，会造成增加或者删除一台服务器或数据库的时候，数据的hash结果变化，导致接入层导入的目标服务器不同，
因此需要引入一致性hash
一致性hash也是取模，是对2的32次方取模，数据取模后，顺时针找到服务器hash值和自己hash值最接近的一个目标服务器。当加入一个新的服务器后，只是这一段hash值的数据会被重新导入到
新的服务器上，其他数据的hash结果不受影响。
一致性hash会引起hash倾斜的问题，如果服务器数量太少。数据有可能会被大量导入到一个服务器上，
可以引入虚拟服务器。将这些虚拟服务器的hash值均匀的分布到hash环上。再做个映射。

游戏相关:
侦同步很数据同步：
1.数据同步。客户端只上发指令，服务端负责运算，再广播数据，难作弊，打击效果差。不公平。断线重连容易，连上来只同步数据，服务端可以做很多处理。比如不在玩家视野内不创建对象等，
2.侦同步，服务器只转发玩家操作指令，服务端只等客户端所有的指令发送完毕后，才广播所有操作，达到公平，也可以是一段时间内不等没有上报操作的玩家。广播。防外挂难，断线重连同步之前所有的玩家操作难。


搜索引擎原理：
1.爬虫-》网页抓取
2.建立倒排索引，每个单词会出现在哪些文档网页中的映射关系落地数据库
3.用户搜索-》分词
4.根据分词-》竞价排名-》根据排名结果在建立好的索引中查询数据库


如何设计单点登录系统SSO，用户只要登录一次就可以访问相互信任的系统，例如登录了淘宝就可以访问天猫
服务端每个接口都要求携带token(用户id+时间戳+随机数)或者sessionid,如果没有则让url跳转到登录界面
浏览器登录验证后服务端创建session,例如使用redis,将token存在redis中, setex来达到自动过期，浏览器将token存在cookie中
之后每次请求所有系统的接口都带上token

秒杀系统：

1.前端设计:

1） 秒杀业务web服务器和其他业务分开部署,当成一个独立的系统，这样不影响普通业务

2） 在秒杀的时间段增加临时带宽

3） 前端在不在秒杀时间点内的点击不发送请求，前端判断商品不够了不发送请求

4） 后端在redis中对数据进行原子操作判断商品是否足够


接入层高可用方案
lvs相比nginx性能更高，可以处理tcp和http请求。性能可以达到每秒10W，是跑在7层网络协议第4层的组件
nginx主要处理http的反向代理负载均衡,性能比lvs低
keeplived是运行在2个负载均衡组件上的，当一个单点挂了，可以启用从
scale up 扩容方案
最外层用2个lvs部署+keeplived保证主从高可用，当一台lvs挂了，keeplived可以导流到另外一台
后面部署nginx做反向代理,由于lvs性能高，只有一台lvs每秒可以抗10W请求

接口的幂等性
接口的幂等性主要是指多次调用一个系统的接口，返回的结果是一致的
1.查询接口，在数据不改变的情况下，查询接口拥有天然的幂等性
2.删除接口，在删除数据后，后面的调用就删不到了，在不考虑返回结果的时候具有天然的幂等性
3.修改接口，update A set a = 1 这种多次调用都是修改为1，这种具有幂等性，update A set a = a+1 这种不具有幂等性
4.增加接口 这种不具有幂等性


解决思路：
在一个订单系统和支付系统中，订单系统调用支付系统的时候，在订单创建的时候创建一个token，将这个token存在redis中，在支付接口调用的时候，要尝试从token中尝试删除这个token，删除成功才能走后续支付流程，这样只有一个调用能调用成功

方法2：
update userAmount set amount = amount - 'value' ,paystatus = 'paid' where orderId= 'orderid' and paystatus = 'unpay'
也就是状态变迁，一个订单已经支付过后，状态就会改变


服务的对外接口的安全
1. 接口使用HTTPS进行数据加密,(非对称算法RSA来交换秘钥，对称加密来加密内容)
2. APPKEY验证法，服务器平台对每个APP生成一对appkey（公钥）,和appsecert(秘钥),客户端在发送数据前，用秘钥对要提交数据进行加密生成一个sign(签名),服务端收到
后用同样用这个appsecert用同样的算法进行签名得到sign。然后对比是否一致。不一致则鉴权失败,成功后返回一个令牌accesstoken
3.通过鉴权的或者登陆过的客户端后面的接口都要带上这个token,服务端对这些接口都进行token验证，在redis中设置这个token的过期时间，每次都进行token验证,过期则要求重新鉴权
4.数据加签，即使https加密过的数据还是有可能被胡乱篡改，需要对数据进行加签验证，例如使用md5来对关键数据进行签名。如果服务器验证不对则抛弃
5.时间戳验证。客户端请求的签名带上时间戳，服务端检查时间戳，判断和当前时间戳的时间差，如果不符合时间差的最小要求则抛弃
6.后端使用防止sql注入的DB操作函数进行DB操作，检查所有参数的有效性，长度等


