数据库:
悲观锁和乐观锁:
乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据
使用版本号的方法，当版本号不一致的情况下进行回滚
悲观锁：总是假设最当坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里
边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁

1.共享锁和排他锁，他们都属于行级锁，都属于悲观锁
共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。SELECT ... LOCK

IN SHARE MODE;

2.排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。 SELECT ... FOR UPDATE;

对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；

引擎:
Innodb和MyISAM的区别
Innodb支持行锁。MyISAM只支持表锁。
Innodb必须有主键或者唯一索引。MyISAM可以没有
Innodb支持外键
Innodb支持事务，MyISAM不支持，相当于每次锁表，并且只能执行一条语句
Innodb更适合大数据的数据库


3.B+树
B树没一个节点有一个N参数，决定了这个节点存在多少个指针或者数据，内部数据也是有序，使用二分查找
B树相对于2叉树的最大区别是。2叉树上面逻辑很近的节点在物理存储上相隔很远，而B树一个节点里的数据是顺序存储，适合做磁盘
B+树相对于B树的区别：B+树的所有数据都存在叶子节点。叶子节点全部用链表串联，方便与扫库，
而B树数据和索引分布在叶子和非叶子节点中，扫库需要递归便利，效率低


索引
1.主键的索引和普通的索引,主键索引的叶子节点包含了整行数据,而普通索引的叶子节点只包含了主键的信息。也就是说通过主键索引查找值只需要查找一次
而通过普通索引要先找到主键，再通过主键走主键索引的树找到元素的数据
2.什么是最左前缀原则,其实就是索引的值都是有序的，左边最小，右边最大，比如用name当索引,然后select * from name like '张%',这时候先定位到张的最左边。然后向又遍历取值
3.数据库为什么用B+树而不是哈希表: 1.首先模糊查找不适应，2.范围查找不适应，因为在B+树种，数值在一定范围内是有序的 
4.主键索引为什么要自增，也是基于索引排列是有序的，插入数据的时候为了能让数据在后面插入,不引起大面积移动
 
 
 
事务的基本要素（ACID）
1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像

没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。

2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。

3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这

张卡转账。

4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

3.事物的隔离级别
Read uncommitted：最低的隔离级别，可以一个事务读到其他事务没有提交的数据。
Read committed：一个事务只能读到其他事务提交了的数据。但是这个事务会读取到其他事务修改的数据（已提交的）。
Repeatable read 在这个事务级别下，一个事务开始读了。其他事务就不可以再修改.但是还可以插入
Serializable 序列化 这个事务级别可以解决在读的情况下，不可以修改也不可以插入，锁表
 

数据库锁是如何实现的，在哪一层实现


SQL语句:
内连接，左连接，右连接。完全连接
内连接：inner json，两表交叉的时候，只出现交叉上的数据
左连接：当显示没有交叉上的数据的时候左表的字段正常，右表的数据是NULL
完全连接: 当没有交叉上的数据，显示2行，一行是左边有数据，右边是NULL，一行是右边有数据，左边是NULL


数据库utf8和utf8mb4的区别，utf8mb4是utf8的超级，占4个字节，utf8只能包含大多数中文。对国外一些文字无法兼容


union 和 union all的区别:
union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。


根据创建时间UNIXTIME，按天汇总统计:
SELECT DATA_FORMAT(createtime, '%Y-%M-%D') as daytime,count(daytime) as count where user group by daytime


查询每门课程成绩都大于80分学生的姓名
select name from stu group by name having name not in (
select name from stu
where score <80)
