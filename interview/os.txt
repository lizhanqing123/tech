
锁的实现：
加锁的过程理解为：
1、read lock；
2、判断lock状态；
3、如果已经加锁，失败返回；
4、把锁状态设置为上锁；
5、返回成功。
每一步都是原子操作
在进入后。操作系统关闭中断，使得线程必须完整执行完。执行完后关闭中断，别的线程进来就被锁住了.或者使用汇编语句test and set，这是一个原子操作，多核的情况下在硬件上锁总线的形式来达到多核的test and set的原子性


自旋锁和互斥锁
自旋锁是一个循环加一个sleep()来实现等待的，如果线程很少，竞争不激烈，恢复时间短,可以使用自旋锁.代表为windows下的crital_section和linux 下spin_lock
互斥锁是把执行权交给操作系统，线程多。竞争激烈时用，代表为mutex

读写锁：
读锁获得锁的时候，其他线程尝试去读可以获得锁，其他线程试图去写，不能获得锁
当写锁获得锁的时候，任何线程都不能获得该锁
读写锁是一种自旋锁
当读模式获得锁的时候，当同时有读写模式锁尝试获得锁的时候，尝试写锁的进程会优先
linux下读写锁的函数是:
pthread_rwlock_rdlock和pthread_rwlock_wrlock
pthread_rwlock_rdlock用来锁住读操作，pthread_rwlock_wrlock用来锁住写操作,读操作的时候只允许读线程获得锁，写线程无法获得锁，
写操作的时候。任何线程不能获得锁
pthread_rwlock_tryrdlock,以非阻塞的方式来尝试获得锁。获得失败。继续望后面走


fork后子进程和父进程的内存关系
fork后。首先代码空间段不会产生拷贝，因为代码空间段是相同的,对于数据空间段,子进程和父进程指向相同的内存页，但当子进程修改数据段内容的时候，会把整个个内存页发生拷贝，这样子进程和父进程就拥有不同的进程空间, 也就是写时拷贝(copy on write),但他们的虚拟地址空间是相同的，对应的物理空间不同
fork返回一个进程ID。这个ID是0的代表是子进程，不是0的是父进程

linux 管道通信
只有2个有血缘关系的进程可以用管道进行通信，例如父子进程
进程结束的时候管道也结束
管道是半双工的。只能向一个方向传输
管道是自带同步机制的，在保证数据安全的前提下，按照特定顺序访问临界资源


mmap,内存映射文件。可以将大文件的物理地址，映射到进程的虚拟空间来用指针操作,可用于大文件的读写操纵。跨进程通信
mmap的返回值就是可供进程操作的指针

段和页的区别
分页和分段系统有许多相似之处，但在概念上两者完全不同，主要表现在： 1、页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。 段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。 2、页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。 段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。

页的大小是4KB

linux的内存管理:
centos linux第一个进程通常是init或者systemd，它是所有进程的父进程，ID为1
其他进程都是由父进程创建。




僵尸进程:
一个进程退出后需要他的父进程来释放他的数据结构，如果父进程类似死循环，那么子进程就没有被释放这个数据结构(PCB)，那么这个子进程就是僵尸进程
一个僵尸进程不占用任何CPU，只是一个没有被释放的数据结构，在ps aux下就是一个defunct

孤儿进程:
如果一个子进程死亡的时候父进程已经死亡(先退出)，那么这个子进程将由进程号为1进程来接管

但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。
